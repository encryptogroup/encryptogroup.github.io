<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>ABY Framework: CBitVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ABY Framework
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Arithmetic Bool Yao Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_c_bit_vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CBitVector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cbitvector_8h_source.html">cbitvector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0e327fc81bc37e2914213f7a70e8b172"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a0e327fc81bc37e2914213f7a70e8b172">CBitVector</a> ()</td></tr>
<tr class="separator:a0e327fc81bc37e2914213f7a70e8b172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad470bc9607569c04d950f8a31215fee8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ad470bc9607569c04d950f8a31215fee8">CBitVector</a> (uint32_t bits)</td></tr>
<tr class="separator:ad470bc9607569c04d950f8a31215fee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587d50aa7307f2846644ddfcf98749a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a587d50aa7307f2846644ddfcf98749a0">CBitVector</a> (uint32_t bits, <a class="el" href="classcrypto.html">crypto</a> *crypt)</td></tr>
<tr class="separator:a587d50aa7307f2846644ddfcf98749a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f10b3bd827dda301dec3d88af0b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a4e6f10b3bd827dda301dec3d88af0b4d">Init</a> ()</td></tr>
<tr class="separator:a4e6f10b3bd827dda301dec3d88af0b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f81531ed4219340aa03294e7f1de1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ad78f81531ed4219340aa03294e7f1de1">~CBitVector</a> ()</td></tr>
<tr class="separator:ad78f81531ed4219340aa03294e7f1de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb30c013fd211bf0eec9cacaf4b087d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#abfb30c013fd211bf0eec9cacaf4b087d">delCBitVector</a> ()</td></tr>
<tr class="separator:abfb30c013fd211bf0eec9cacaf4b087d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3819ba1f6d80d838abbd0e93041ce5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ac3819ba1f6d80d838abbd0e93041ce5a">FillRand</a> (uint32_t bits, <a class="el" href="classcrypto.html">crypto</a> *crypt)</td></tr>
<tr class="separator:ac3819ba1f6d80d838abbd0e93041ce5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d010b478a05a56b5bfa762e19641ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create</a> (uint64_t bits)</td></tr>
<tr class="separator:a84d010b478a05a56b5bfa762e19641ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8152f869cce43fcc2216386afc21a643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a8152f869cce43fcc2216386afc21a643">CreateBytes</a> (uint64_t bytes)</td></tr>
<tr class="separator:a8152f869cce43fcc2216386afc21a643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465c6c58b64215794bcbf927b79c6b0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a465c6c58b64215794bcbf927b79c6b0b">CreateZeros</a> (uint64_t bits)</td></tr>
<tr class="separator:a465c6c58b64215794bcbf927b79c6b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba9d34a34ca16fee372039fcc9d17a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#afba9d34a34ca16fee372039fcc9d17a1">Create</a> (uint64_t bits, <a class="el" href="classcrypto.html">crypto</a> *crypt)</td></tr>
<tr class="separator:afba9d34a34ca16fee372039fcc9d17a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9652e4d7e14bc6f7c0e1b29d06a7130a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a9652e4d7e14bc6f7c0e1b29d06a7130a">Create</a> (uint64_t numelements, uint64_t elementlength)</td></tr>
<tr class="separator:a9652e4d7e14bc6f7c0e1b29d06a7130a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eab7cb5f8029901e14af6778d57f8d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a0eab7cb5f8029901e14af6778d57f8d3">Create</a> (uint64_t numelements, uint64_t elementlength, <a class="el" href="classcrypto.html">crypto</a> *crypt)</td></tr>
<tr class="separator:a0eab7cb5f8029901e14af6778d57f8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32318bef03278747aa9cf8b8a241030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ad32318bef03278747aa9cf8b8a241030">Create</a> (uint64_t numelementsDimA, uint64_t numelementsDimB, uint64_t elementlength)</td></tr>
<tr class="separator:ad32318bef03278747aa9cf8b8a241030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643106324dfcdac8effd8ae185d1343a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a643106324dfcdac8effd8ae185d1343a">Create</a> (uint64_t numelementsDimA, uint64_t numelementsDimB, uint64_t elementlength, <a class="el" href="classcrypto.html">crypto</a> *crypt)</td></tr>
<tr class="separator:a643106324dfcdac8effd8ae185d1343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4237185a0ebf54614bd6250b4e60a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ab4237185a0ebf54614bd6250b4e60a1e">ResizeinBytes</a> (int newSizeBytes)</td></tr>
<tr class="separator:ab4237185a0ebf54614bd6250b4e60a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48146fc1124ad63d930a6ea3d8e76c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a48146fc1124ad63d930a6ea3d8e76c11">Reset</a> ()</td></tr>
<tr class="separator:a48146fc1124ad63d930a6ea3d8e76c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f1256613f532b1d728c2c36223931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a0d2f1256613f532b1d728c2c36223931">ResetFromTo</a> (int frombyte, int tobyte)</td></tr>
<tr class="separator:a0d2f1256613f532b1d728c2c36223931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06967330a3ea126866475abb09d06b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ac06967330a3ea126866475abb09d06b3">SetToOne</a> ()</td></tr>
<tr class="separator:ac06967330a3ea126866475abb09d06b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bcafefe7b29c8c64ab45258f2b3e82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a82bcafefe7b29c8c64ab45258f2b3e82">GetSize</a> ()</td></tr>
<tr class="separator:a82bcafefe7b29c8c64ab45258f2b3e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace95eb69514a8f3b1866f64237598228"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ace95eb69514a8f3b1866f64237598228">IsEqual</a> (<a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;vec)</td></tr>
<tr class="separator:ace95eb69514a8f3b1866f64237598228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc59bed770c67a6300b9d4c0120fc51"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#aabc59bed770c67a6300b9d4c0120fc51">IsEqual</a> (<a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;vec, int from, int to)</td></tr>
<tr class="separator:aabc59bed770c67a6300b9d4c0120fc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154810d495493eb274b0918deea159f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a154810d495493eb274b0918deea159f0">SetElementLength</a> (int elelen)</td></tr>
<tr class="separator:a154810d495493eb274b0918deea159f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c4cbdfd0562d4bf0878cc481ae2166"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a56c4cbdfd0562d4bf0878cc481ae2166">GetElementLength</a> ()</td></tr>
<tr class="separator:a56c4cbdfd0562d4bf0878cc481ae2166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e6085997f64cec320a428b99367b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a10e6085997f64cec320a428b99367b89">Copy</a> (<a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;vec)</td></tr>
<tr class="separator:a10e6085997f64cec320a428b99367b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e10ebc700e6eaa19e49d041a0c60a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a996e10ebc700e6eaa19e49d041a0c60a">Copy</a> (<a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;vec, int pos, int len)</td></tr>
<tr class="separator:a996e10ebc700e6eaa19e49d041a0c60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a05178228bc597a5a66c26cd3f8f0ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a1a05178228bc597a5a66c26cd3f8f0ef">Copy</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:a1a05178228bc597a5a66c26cd3f8f0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c591e1e5f5efdba62d28bb3c733515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#af7c591e1e5f5efdba62d28bb3c733515">XOR_no_mask</a> (int p, int bitPos, int bitLen)</td></tr>
<tr class="separator:af7c591e1e5f5efdba62d28bb3c733515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a8614cf0fc79043602aac083781307"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a40a8614cf0fc79043602aac083781307">GetInt</a> (int bitPos, int bitLen)</td></tr>
<tr class="separator:a40a8614cf0fc79043602aac083781307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa2c3db137c95be38a28507928237bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a6aa2c3db137c95be38a28507928237bb">ORByte</a> (int pos, BYTE p)</td></tr>
<tr class="separator:a6aa2c3db137c95be38a28507928237bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b28ceb8806d5635e4c7df0d105cf709"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a2b28ceb8806d5635e4c7df0d105cf709">GetBit</a> (int idx)</td></tr>
<tr class="separator:a2b28ceb8806d5635e4c7df0d105cf709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4775aef59942f5bef497a8e5ecd818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a8c4775aef59942f5bef497a8e5ecd818">SetBit</a> (int idx, BYTE b)</td></tr>
<tr class="separator:a8c4775aef59942f5bef497a8e5ecd818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c19baf537b532b74ee8d4f2fba516c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a1c19baf537b532b74ee8d4f2fba516c5">XORBit</a> (int idx, BYTE b)</td></tr>
<tr class="separator:a1c19baf537b532b74ee8d4f2fba516c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0901dd5e52643359b6753125b3e6cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a5a0901dd5e52643359b6753125b3e6cd">ANDBit</a> (int idx, BYTE b)</td></tr>
<tr class="separator:a5a0901dd5e52643359b6753125b3e6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93883bf4914d1dc028a5f3e0631d7952"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a93883bf4914d1dc028a5f3e0631d7952">GetBitNoMask</a> (int idx)</td></tr>
<tr class="separator:a93883bf4914d1dc028a5f3e0631d7952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9996cb024410ad0b0bc8fbc4496a82bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a9996cb024410ad0b0bc8fbc4496a82bc">SetBitNoMask</a> (int idx, BYTE b)</td></tr>
<tr class="separator:a9996cb024410ad0b0bc8fbc4496a82bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a741227827d658c1715deec220032b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a72a741227827d658c1715deec220032b">XORBitNoMask</a> (int idx, BYTE b)</td></tr>
<tr class="separator:a72a741227827d658c1715deec220032b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c33fdc7612480239624a5bf73c368d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a59c33fdc7612480239624a5bf73c368d">ANDBitNoMask</a> (int idx, BYTE b)</td></tr>
<tr class="separator:a59c33fdc7612480239624a5bf73c368d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0df36cd75420fbf3662b3b2a43ff98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a2a0df36cd75420fbf3662b3b2a43ff98">SetByte</a> (int idx, BYTE p)</td></tr>
<tr class="separator:a2a0df36cd75420fbf3662b3b2a43ff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985267d6e158994938ef0664fe7de259"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a985267d6e158994938ef0664fe7de259">GetByte</a> (int idx)</td></tr>
<tr class="separator:a985267d6e158994938ef0664fe7de259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5896f8fca8729c743deac7e99c361ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a5896f8fca8729c743deac7e99c361ca7">XORByte</a> (int idx, BYTE b)</td></tr>
<tr class="separator:a5896f8fca8729c743deac7e99c361ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701ec8dc5658058218ab0ac8be05aa48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a701ec8dc5658058218ab0ac8be05aa48">ANDByte</a> (int idx, BYTE b)</td></tr>
<tr class="separator:a701ec8dc5658058218ab0ac8be05aa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85139fc0623f0c8792511fa2bac23865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a85139fc0623f0c8792511fa2bac23865">GetBits</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:a85139fc0623f0c8792511fa2bac23865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea918d3f0741daf876408cb4182c1b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#aea918d3f0741daf876408cb4182c1b17">GetBytes</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:aea918d3f0741daf876408cb4182c1b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8666c4c173d9ef848d228c22d8dac64"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab8666c4c173d9ef848d228c22d8dac64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ab8666c4c173d9ef848d228c22d8dac64">GetBytes</a> (T *dst, T *src, T *lim)</td></tr>
<tr class="separator:ab8666c4c173d9ef848d228c22d8dac64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9ec30c7ce0e57b35fb1dee84f6b227"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aab9ec30c7ce0e57b35fb1dee84f6b227"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#aab9ec30c7ce0e57b35fb1dee84f6b227">Get</a> (int pos, int len)</td></tr>
<tr class="separator:aab9ec30c7ce0e57b35fb1dee84f6b227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ebf3ca25a520cba5c4fc3e35028f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a309ebf3ca25a520cba5c4fc3e35028f9">SetBits</a> (BYTE *p, uint64_t pos, uint64_t len)</td></tr>
<tr class="separator:a309ebf3ca25a520cba5c4fc3e35028f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb6250074ff4317e67ecdfc99047260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a1cb6250074ff4317e67ecdfc99047260">SetBits</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:a1cb6250074ff4317e67ecdfc99047260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d1e30af12e0e4f4d432186c1b0b40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a18d1e30af12e0e4f4d432186c1b0b40d">SetBitsPosOffset</a> (BYTE *p, int ppos, int pos, int len)</td></tr>
<tr class="separator:a18d1e30af12e0e4f4d432186c1b0b40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57566943e8183748b39fa85805ef3fff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a57566943e8183748b39fa85805ef3fff">SetBytes</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:a57566943e8183748b39fa85805ef3fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2f8e170922b9c991642a8d36043719"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a2f8e170922b9c991642a8d36043719"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a6a2f8e170922b9c991642a8d36043719">SetBytes</a> (T *dst, T *src, T *lim)</td></tr>
<tr class="separator:a6a2f8e170922b9c991642a8d36043719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5573a0b254514ed8de9d7432e9d86033"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5573a0b254514ed8de9d7432e9d86033"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a5573a0b254514ed8de9d7432e9d86033">Set</a> (T val, int pos, int len)</td></tr>
<tr class="separator:a5573a0b254514ed8de9d7432e9d86033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfcce1c2beadebd6762ea83f2b100a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a7cfcce1c2beadebd6762ea83f2b100a0">SetBitsToZero</a> (int bitpos, int bitlen)</td></tr>
<tr class="separator:a7cfcce1c2beadebd6762ea83f2b100a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263d8b59ba682177f0ce45fac658098c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a263d8b59ba682177f0ce45fac658098c">XORBytes</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:a263d8b59ba682177f0ce45fac658098c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ce0adaeaf9fd9b56a362eada3bbba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a498ce0adaeaf9fd9b56a362eada3bbba">XORBytes</a> (BYTE *p, int len)</td></tr>
<tr class="separator:a498ce0adaeaf9fd9b56a362eada3bbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afd43a5ba95477f8a6d9746ec7f7a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a9afd43a5ba95477f8a6d9746ec7f7a82">XORVector</a> (<a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;vec, int pos, int len)</td></tr>
<tr class="separator:a9afd43a5ba95477f8a6d9746ec7f7a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec76212bf95a668f212f191dc70f5149"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aec76212bf95a668f212f191dc70f5149"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#aec76212bf95a668f212f191dc70f5149">XOR</a> (T val, int pos, int len)</td></tr>
<tr class="separator:aec76212bf95a668f212f191dc70f5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d8f5d6f91e48534739b7f43943c9fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a02d8f5d6f91e48534739b7f43943c9fb">XORBits</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:a02d8f5d6f91e48534739b7f43943c9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057a35cc675262513498ac61cad198f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a057a35cc675262513498ac61cad198f9">XORBitsPosOffset</a> (BYTE *p, int ppos, int pos, int len)</td></tr>
<tr class="separator:a057a35cc675262513498ac61cad198f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9265d158f116f48f4eec520a27212f1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af9265d158f116f48f4eec520a27212f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#af9265d158f116f48f4eec520a27212f1">XORBytes</a> (T *dst, T *src, T *lim)</td></tr>
<tr class="separator:af9265d158f116f48f4eec520a27212f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d21dc2673b728462c08eda0ff0d343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ab6d21dc2673b728462c08eda0ff0d343">XORRepeat</a> (BYTE *p, int pos, int len, int <a class="el" href="classnum.html">num</a>)</td></tr>
<tr class="separator:ab6d21dc2673b728462c08eda0ff0d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46c00c3986e7c22988a9e40ad1401b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ac46c00c3986e7c22988a9e40ad1401b4">XORBytesReverse</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:ac46c00c3986e7c22988a9e40ad1401b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16049116df333c9498b2b26cde3530f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a16049116df333c9498b2b26cde3530f4">ANDBytes</a> (BYTE *p, int pos, int len)</td></tr>
<tr class="separator:a16049116df333c9498b2b26cde3530f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adad44f780a645d5489f12c30703b02"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5adad44f780a645d5489f12c30703b02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a5adad44f780a645d5489f12c30703b02">ANDBytes</a> (T *dst, T *src, T *lim)</td></tr>
<tr class="separator:a5adad44f780a645d5489f12c30703b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833c9d66e3222c5e9a01d9a983961442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a833c9d66e3222c5e9a01d9a983961442">SetXOR</a> (BYTE *p, BYTE *q, int pos, int len)</td></tr>
<tr class="separator:a833c9d66e3222c5e9a01d9a983961442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad529794892a4a742851ccf77f37b72bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ad529794892a4a742851ccf77f37b72bd">SetAND</a> (BYTE *p, BYTE *q, int pos, int len)</td></tr>
<tr class="separator:ad529794892a4a742851ccf77f37b72bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5967a41d1dd1a254ce196722f6c68d"><td class="memItemLeft" align="right" valign="top">BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#aad5967a41d1dd1a254ce196722f6c68d">GetArr</a> ()</td></tr>
<tr class="separator:aad5967a41d1dd1a254ce196722f6c68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c33f2491c526892da0c535644d813a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a9c33f2491c526892da0c535644d813a7">AttachBuf</a> (BYTE *p, int size=-1)</td></tr>
<tr class="separator:a9c33f2491c526892da0c535644d813a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a588deb16b35b87af9bc1a6e59bf710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a0a588deb16b35b87af9bc1a6e59bf710">AttachBuf</a> (BYTE *p, uint64_t size=-1)</td></tr>
<tr class="separator:a0a588deb16b35b87af9bc1a6e59bf710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e034dbbbe7efafde0507dfe4e2daf37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a8e034dbbbe7efafde0507dfe4e2daf37">DetachBuf</a> ()</td></tr>
<tr class="separator:a8e034dbbbe7efafde0507dfe4e2daf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00441afa14ef881eb25b2ca676088f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#aa00441afa14ef881eb25b2ca676088f2">Print</a> (int fromBit, int toBit)</td></tr>
<tr class="separator:aa00441afa14ef881eb25b2ca676088f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec292cf93910f3ce9ca427f677958da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#afec292cf93910f3ce9ca427f677958da">PrintHex</a> ()</td></tr>
<tr class="separator:afec292cf93910f3ce9ca427f677958da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eca0fb581fb6dc3a0fdaeb84069d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a01eca0fb581fb6dc3a0fdaeb84069d7a">PrintHex</a> (int fromByte, int toByte)</td></tr>
<tr class="separator:a01eca0fb581fb6dc3a0fdaeb84069d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c39c4899a143f2cc5d9f728f4410586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a9c39c4899a143f2cc5d9f728f4410586">PrintBinary</a> ()</td></tr>
<tr class="separator:a9c39c4899a143f2cc5d9f728f4410586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab345a6b215839a01e547ab3d54773646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ab345a6b215839a01e547ab3d54773646">PrintContent</a> ()</td></tr>
<tr class="separator:ab345a6b215839a01e547ab3d54773646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cfb99f0a20a8b45f38d37eb3fc7b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#ac5cfb99f0a20a8b45f38d37eb3fc7b00">PrintBinaryMasked</a> (int from, int to)</td></tr>
<tr class="separator:ac5cfb99f0a20a8b45f38d37eb3fc7b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0c87c5eddf7a18cf3145bd2ba64c36"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adc0c87c5eddf7a18cf3145bd2ba64c36"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#adc0c87c5eddf7a18cf3145bd2ba64c36">Get</a> (int i)</td></tr>
<tr class="separator:adc0c87c5eddf7a18cf3145bd2ba64c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394b44a53678cfc641730e655c7e496"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7394b44a53678cfc641730e655c7e496"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a7394b44a53678cfc641730e655c7e496">Set</a> (T val, int i)</td></tr>
<tr class="separator:a7394b44a53678cfc641730e655c7e496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c06ba63a5fbc2cda03a7fae02bd5709"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c06ba63a5fbc2cda03a7fae02bd5709"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a6c06ba63a5fbc2cda03a7fae02bd5709">Get2D</a> (int i, int j)</td></tr>
<tr class="separator:a6c06ba63a5fbc2cda03a7fae02bd5709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15616ece0d9d626a6fabf1b0495ef580"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a15616ece0d9d626a6fabf1b0495ef580"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_c_bit_vector.html#a15616ece0d9d626a6fabf1b0495ef580">Set2D</a> (T val, int i, int j)</td></tr>
<tr class="separator:a15616ece0d9d626a6fabf1b0495ef580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96c25e3cef746e011acb0f3bf7261c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af96c25e3cef746e011acb0f3bf7261c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EklundhBitTranspose</b> (int rows, int columns)</td></tr>
<tr class="separator:af96c25e3cef746e011acb0f3bf7261c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19aca5ecbf4cc320e284b32c4ec1a093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19aca5ecbf4cc320e284b32c4ec1a093"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleTranspose</b> (int rows, int columns)</td></tr>
<tr class="separator:a19aca5ecbf4cc320e284b32c4ec1a093"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class which defines the functionality of storing C-based Bits in vector type format. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0e327fc81bc37e2914213f7a70e8b172"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CBitVector::CBitVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor which initializes the member variables bit pointer and size to NULL and zero respectively. </p>

</div>
</div>
<a class="anchor" id="ad470bc9607569c04d950f8a31215fee8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CBitVector::CBitVector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded constructor of class <a class="el" href="class_c_bit_vector.html">CBitVector</a> which calls internally <a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create(uint64_t bits)</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>- It is the number of bits which will be used to allocate the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with. For more info on how these bits are allocated refer to <a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create(uint64_t bits)</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a587d50aa7307f2846644ddfcf98749a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CBitVector::CBitVector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto.html">crypto</a> *&#160;</td>
          <td class="paramname"><em>crypt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded constructor of class <a class="el" href="class_c_bit_vector.html">CBitVector</a> which calls internally <a class="el" href="class_c_bit_vector.html#afba9d34a34ca16fee372039fcc9d17a1">Create(uint64_t bits,crypto* crypt)</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>- It is the number of bits which will be used to allocate the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with. For more info on how these bits are allocated refer to <a class="el" href="class_c_bit_vector.html#afba9d34a34ca16fee372039fcc9d17a1">Create(uint64_t bits,crypto* crypt)</a> </td></tr>
    <tr><td class="paramname">crypt</td><td>- This object from crypto class is used to generate pseudo random values for the cbitvector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad78f81531ed4219340aa03294e7f1de1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CBitVector::~CBitVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor which internally calls the delCBitVector for deallocating the space. This method internally calls <a class="el" href="class_c_bit_vector.html#abfb30c013fd211bf0eec9cacaf4b087d">delCBitVector()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5a0901dd5e52643359b6753125b3e6cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::ANDBit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method ANDs the bit in the provided index by using the maskbits and the provided bit. The maskbits brings the concept of endianness in the vector. In this method C_MASK_BIT is used to extract and set the bits which are assumed to be organized in Little Endian form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Bit Index which needs to be ANDed to in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>- The bit which being ANDed in the provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59c33fdc7612480239624a5bf73c368d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::ANDBitNoMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method ANDs the bit in the provided index without using the maskbits. The maskbits brings the concept of endianness in the vector. In this method mask bits are not used so the vector is treated in Big Endian form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Bit Index which needs to be ANDed to in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>- The bit which being ANDed in the provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a701ec8dc5658058218ab0ac8be05aa48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::ANDByte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method performs AND operation at the given index in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a provided Byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Index of the byte which needs to be ANDed inside the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>- Byte to be ANDed with the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16049116df333c9498b2b26cde3530f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::ANDBytes </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method performs AND operation from a given position in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a provided Byte Array with a length. This method internally calls <a class="el" href="class_c_bit_vector.html#a5adad44f780a645d5489f12c30703b02">ANDBytes(T* dst, T* src, T* lim)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte Array to be ANDed with the <a class="el" href="class_c_bit_vector.html">CBitVector</a> range. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset for ANDing into current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be ANDed to the current vector from provided byte location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5adad44f780a645d5489f12c30703b02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::ANDBytes </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic method which is used to AND byte wise the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. This method is called from <a class="el" href="class_c_bit_vector.html#a16049116df333c9498b2b26cde3530f4">ANDBytes(BYTE* p, int pos, int len)</a>. </p>

</div>
</div>
<a class="anchor" id="a9c33f2491c526892da0c535644d813a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::AttachBuf </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to attach a new buffer into the <a class="el" href="class_c_bit_vector.html">CBitVector</a> provided as arguments to this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Pointer to the byte location to be attached to the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">size</td><td>- Number of bytes attached from the provided buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a588deb16b35b87af9bc1a6e59bf710"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::AttachBuf </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to attach a new buffer into the <a class="el" href="class_c_bit_vector.html">CBitVector</a> provided as arguments to this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Pointer to the byte location to be attached to the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">size</td><td>- Number of bytes attached from the provided buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10e6085997f64cec320a428b99367b89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to copy the provided <a class="el" href="class_c_bit_vector.html">CBitVector</a> to itself. It internally calls <a class="el" href="class_c_bit_vector.html#a1a05178228bc597a5a66c26cd3f8f0ef">Copy(BYTE* p, int pos, int len)</a> for copying bytewise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- The vector from which the copying needs to be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a996e10ebc700e6eaa19e49d041a0c60a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to copy the provided <a class="el" href="class_c_bit_vector.html">CBitVector</a> to itself for a given range. It internally calls <a class="el" href="class_c_bit_vector.html#a1a05178228bc597a5a66c26cd3f8f0ef">Copy(BYTE* p, int pos, int len)</a> for copying bytewise. Copying is done in a slightly different way. Here the range is pos and len. The offset is defined for the base vector and not for the copying vector. So if the method is called as B.Copy(A,5,10) then, values of vector A will be copied from first index location for length 10 to the vector B from position 5 for length 10. Unlike copying values from 5 position in vector A to vector B for length 10. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- The vector from which the copying needs to be performed. </td></tr>
    <tr><td class="paramname">pos</td><td>- The positional offset for copying into current vector. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be copied to the current vector from provided vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a05178228bc597a5a66c26cd3f8f0ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Copy </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to copy the current <a class="el" href="class_c_bit_vector.html">CBitVector</a> with some ByteLocation with positional shift and length. This method is the base method for methods <a class="el" href="class_c_bit_vector.html#a996e10ebc700e6eaa19e49d041a0c60a">Copy(CBitVector&amp; vec, int pos, int len)</a> and <a class="el" href="class_c_bit_vector.html#a10e6085997f64cec320a428b99367b89">Copy(CBitVector&amp; vec)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Pointer to the byte location to be copied to the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset for copying into current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be copied to the current vector from provided byte location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84d010b478a05a56b5bfa762e19641ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Create </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to create the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided bits. The method creates a bit vector with a size close to AES Bitsize. For example, if bit size provided is 110. After this method is called it will be 128 bits. It will perform a ceil of provided_bit_size to AES bit size and multiply that ceiled value with AES bits size. (For reference, AES Bit size is taken as 128 bits)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>- It is the number of bits which will be used to allocate the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afba9d34a34ca16fee372039fcc9d17a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Create </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto.html">crypto</a> *&#160;</td>
          <td class="paramname"><em>crypt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to create the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided bits and set them to some random values. The method creates a bit vector with a size close to AES Bitsize. And performs an assignment of random values to each bit being allocated. Internally, this method calls <a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create(uint64_t bits)</a> and <a class="el" href="class_c_bit_vector.html#ac3819ba1f6d80d838abbd0e93041ce5a">FillRand(uint32_t bits, crypto* crypt)</a>. Therefore, for further info please refer to the internal method provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>- It is the number of bits which will be used to allocate and assign random values of the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with. </td></tr>
    <tr><td class="paramname">crypt</td><td>- It is the crypto class object which is used to generate random values for the bit size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9652e4d7e14bc6f7c0e1b29d06a7130a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Create </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numelements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elementlength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used create the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided number of elements and element length. This method basically creates a 1-dimensional array/vector with the provided element size and number of elements. This method internally calls <a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create(uint64_t bits)</a> with arguments as elementlength*numelements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numelements</td><td>- The number of elements in the 1-dimensional array/vector which gets created. </td></tr>
    <tr><td class="paramname">elementlength</td><td>- The size of element in the provided cbitvector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0eab7cb5f8029901e14af6778d57f8d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Create </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numelements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elementlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto.html">crypto</a> *&#160;</td>
          <td class="paramname"><em>crypt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used create the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided number of elements and element length and then assign random values to them. This method basically creates a 1-dimensional array/vector with the provided element size and number of elements and assign some random values based on crypt object provided. This method internally calls <a class="el" href="class_c_bit_vector.html#afba9d34a34ca16fee372039fcc9d17a1">Create(uint64_t bits, crypto* crypt)</a> for creation of 1-d vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numelements</td><td>- The number of elements in the 1-dimensional array/vector which gets created. </td></tr>
    <tr><td class="paramname">elementlength</td><td>- The size of element in the provided cbitvector. </td></tr>
    <tr><td class="paramname">crypt</td><td>- It is the crypto class object which is used to generate random values for the provided bit size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad32318bef03278747aa9cf8b8a241030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Create </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numelementsDimA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numelementsDimB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elementlength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used create the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided number of elements of 2 dimensions and element length. This method basically creates a 2-dimensional array/vector with the provided element size and number of elements in two dimensions. This method internally calls <a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create(uint64_t bits)</a> with arguments as elementlength*numelementsDimA*numelementsDimB. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numelementsDimA</td><td>- The number of elements in the 1st-dimension of the 2d array/vector which gets created. </td></tr>
    <tr><td class="paramname">numelementsDimB</td><td>- The number of elements in the 2nd-dimension of the 2d array/vector which gets created. </td></tr>
    <tr><td class="paramname">elementlength</td><td>- The size of element in the provided cbitvector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a643106324dfcdac8effd8ae185d1343a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Create </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numelementsDimA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numelementsDimB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elementlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto.html">crypto</a> *&#160;</td>
          <td class="paramname"><em>crypt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used create the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided number of elements of 2 dimensions and element length, and then assign random values to them. This method basically creates a 2-dimensional array/vector with the provided element size and number of elements in two dimensions and assign some random values based on crypt object provided. This method internally calls <a class="el" href="class_c_bit_vector.html#afba9d34a34ca16fee372039fcc9d17a1">Create(uint64_t bits, crypto* crypt)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numelementsDimA</td><td>- The number of elements in the 1st-dimension of the 2d array/vector which gets created. </td></tr>
    <tr><td class="paramname">numelementsDimB</td><td>- The number of elements in the 2nd-dimension of the 2d array/vector which gets created. </td></tr>
    <tr><td class="paramname">elementlength</td><td>- The size of element in the provided cbitvector. </td></tr>
    <tr><td class="paramname">crypt</td><td>- It is the crypto class object which is used to generate random values for the provided bit size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8152f869cce43fcc2216386afc21a643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::CreateBytes </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to create the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided byte size. The method creates a bit vector with a size close to AES Bytesize. For example, if byte size provided is 9. After this method is called it will be 16 bytes. It will perform a ceil of provided_byte_size to AES byte size and multiply that ceiled value with AES byte size. (For reference, AES Byte size is taken as 16 bytes). Internally, this method calls <a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create(uint64_t bits)</a>. Therefore, for further info please refer to the internal method provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>- It is the number of bits which will be used to allocate the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a465c6c58b64215794bcbf927b79c6b0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::CreateZeros </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to create the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided bits and set them to value zero. The method creates a bit vector with a size close to AES Bitsize. And performs an assignment of zero to each bit being allocated. Internally, this method calls <a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create(uint64_t bits)</a>. Therefore, for further info please refer to the internal method provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>- It is the number of bits which will be used to allocate and assign zero values of the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfb30c013fd211bf0eec9cacaf4b087d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::delCBitVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to deallocate the bit pointer and size explicitly. This method needs to be called by the programmer explicitly. </p>

</div>
</div>
<a class="anchor" id="a8e034dbbbe7efafde0507dfe4e2daf37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::DetachBuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to detach the buffer from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </p>

</div>
</div>
<a class="anchor" id="ac3819ba1f6d80d838abbd0e93041ce5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::FillRand </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcrypto.html">crypto</a> *&#160;</td>
          <td class="paramname"><em>crypt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method generates random values and assigns it to the bitvector using crypto object. If the bits provided in the params are greater than the bit size of the bitvector, then the bit vector is recreated with new bit size and filled in with random values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>- It is the number of bits which will be used to allocate and assign random values of the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with. For more info on how these bits are allocated refer to <a class="el" href="class_c_bit_vector.html#a84d010b478a05a56b5bfa762e19641ad">Create(uint64_t bits)</a> </td></tr>
    <tr><td class="paramname">crypt</td><td>- It is the crypto class object which is used to generate random values for the bit size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab9ec30c7ce0e57b35fb1dee84f6b227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CBitVector::Get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic method which performs the operation of getting values from a <a class="el" href="class_c_bit_vector.html">CBitVector</a> for a given bit position and length. This method internally calls <a class="el" href="class_c_bit_vector.html#a85139fc0623f0c8792511fa2bac23865">GetBits(BYTE* p, int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- The positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> from which the data needs to obtained. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the value/values for the provided range. </dd></dl>

</div>
</div>
<a class="anchor" id="adc0c87c5eddf7a18cf3145bd2ba64c36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CBitVector::Get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic method which provides more abstraction for getting elements in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. It is mainly used for getting values which are 1-dimensional in nature. This method internally calls <a class="el" href="class_c_bit_vector.html#aab9ec30c7ce0e57b35fb1dee84f6b227">Get(int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>- Index from which data needs to be fetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c06ba63a5fbc2cda03a7fae02bd5709"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CBitVector::Get2D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic method which provides more abstraction for getting elements in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. It is mainly used for getting values which are 2-dimensional in nature. This method internally calls <a class="el" href="class_c_bit_vector.html#aab9ec30c7ce0e57b35fb1dee84f6b227">Get(int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>- Row index from which the data needs to be read. </td></tr>
    <tr><td class="paramname">j</td><td>- Column index from which the data needs to be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad5967a41d1dd1a254ce196722f6c68d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BYTE* CBitVector::GetArr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns <a class="el" href="class_c_bit_vector.html">CBitVector</a> in byte array format. This is very widely used method. </p>

</div>
</div>
<a class="anchor" id="a2b28ceb8806d5635e4c7df0d105cf709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BYTE CBitVector::GetBit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets the bit in the provided index by using the maskbits. The maskbits brings the concept of endianness in the vector. In this method MASK_BIT is used to extract the bits which are assumed to be organized in Little Endian form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Bit Index which needs to be fetched from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte which has got just the bit in it. </dd></dl>

</div>
</div>
<a class="anchor" id="a93883bf4914d1dc028a5f3e0631d7952"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BYTE CBitVector::GetBitNoMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets the bit in the provided index without using the maskbits. The maskbits brings the concept of endianness in the vector. In this method mask bits are not used so the vector is treated in Big Endian form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Bit Index which needs to be fetched from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte which has got just the bit in it. </dd></dl>

</div>
</div>
<a class="anchor" id="a85139fc0623f0c8792511fa2bac23865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::GetBits </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method gets elements from the <a class="el" href="class_c_bit_vector.html">CBitVector</a> bitwise from a given offset for a given length. And stores the result in the provided byte pointer. This method is used by the generic method <a class="el" href="class_c_bit_vector.html#aab9ec30c7ce0e57b35fb1dee84f6b227">Get(int pos, int len)</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- The resulting bits for the given range in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> is stored in the byte pointer p. </td></tr>
    <tr><td class="paramname">pos</td><td>- The positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> from which the data needs to obtained. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a985267d6e158994938ef0664fe7de259"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BYTE CBitVector::GetByte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the byte at the given index in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. Here the index is w.r.t bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Index of the byte which needs to be returned from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Byte is returned from <a class="el" href="class_c_bit_vector.html">CBitVector</a> at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="aea918d3f0741daf876408cb4182c1b17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::GetBytes </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method gets elements from the <a class="el" href="class_c_bit_vector.html">CBitVector</a> bytewise from a given offset for a given length. And stores the result in the provided byte pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- The resulting bits for the given range in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> is stored in the byte pointer p. </td></tr>
    <tr><td class="paramname">pos</td><td>- The positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> from which the data needs to obtained. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8666c4c173d9ef848d228c22d8dac64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::GetBytes </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic method which performs the operation of getting bytes from source for the given limit. </p>

</div>
</div>
<a class="anchor" id="a56c4cbdfd0562d4bf0878cc481ae2166"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CBitVector::GetElementLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method gets the element length of the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </p><dl class="section return"><dt>Returns</dt><dd>element length of the elements in <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a40a8614cf0fc79043602aac083781307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int CBitVector::GetInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated </p>

</div>
</div>
<a class="anchor" id="a82bcafefe7b29c8c64ab45258f2b3e82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CBitVector::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a getter method which returns the size of the <a class="el" href="class_c_bit_vector.html">CBitVector</a> in bytes. </p><dl class="section return"><dt>Returns</dt><dd>the byte size of <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e6f10b3bd827dda301dec3d88af0b4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function which gets called initially when the cbitvector object is created. This method is mostly called from constructor of <a class="el" href="class_c_bit_vector.html">CBitVector</a> class. The method sets bit pointer and size to NULL and zero respectively. </p>

</div>
</div>
<a class="anchor" id="ace95eb69514a8f3b1866f64237598228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CBitVector::IsEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method checks if two CBitVectors are equal or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- Vector to be checked with current one for the case of equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean value which says whether it is equal or not. </dd></dl>

</div>
</div>
<a class="anchor" id="aabc59bed770c67a6300b9d4c0120fc51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CBitVector::IsEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method checks if two CBitVectors are equal or not for a given range of bit positions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- Vector to be checked with current one for the case of equality. </td></tr>
    <tr><td class="paramname">from</td><td>- Bit Position from which the vectors need to be checked for equality. </td></tr>
    <tr><td class="paramname">to</td><td>- Bit Position until which the vectors need to be checked for equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean value which says whether the vectors are equal or not in the provided range of bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a6aa2c3db137c95be38a28507928237bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::ORByte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method performs OR operation bytewise with the current <a class="el" href="class_c_bit_vector.html">CBitVector</a> at the provided byte position with another Byte object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- Byte position in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> which is used to perform OR operation with. </td></tr>
    <tr><td class="paramname">p</td><td>- Byte with which the OR operation is performed to get the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa00441afa14ef881eb25b2ca676088f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromBit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toBit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method prints the <a class="el" href="class_c_bit_vector.html">CBitVector</a> bitwise for provided bit range. This method internally calls <a class="el" href="class_c_bit_vector.html#a93883bf4914d1dc028a5f3e0631d7952">GetBitNoMask(int idx)</a>. This method is called from <a class="el" href="class_c_bit_vector.html#a9c39c4899a143f2cc5d9f728f4410586">PrintBinary()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromBit</td><td>- The bit from which the printing starts in a <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">toBit</td><td>- The bit until which the printing in a <a class="el" href="class_c_bit_vector.html">CBitVector</a> is done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c39c4899a143f2cc5d9f728f4410586"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::PrintBinary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method prints the <a class="el" href="class_c_bit_vector.html">CBitVector</a> in Binary format. This method internally calls <a class="el" href="class_c_bit_vector.html#aa00441afa14ef881eb25b2ca676088f2">Print(int fromBit, int toBit)</a>. </p>

</div>
</div>
<a class="anchor" id="ac5cfb99f0a20a8b45f38d37eb3fc7b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::PrintBinaryMasked </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method prints the <a class="el" href="class_c_bit_vector.html">CBitVector</a> bitwise for provided bit range with mask. This method internally calls <a class="el" href="class_c_bit_vector.html#a2b28ceb8806d5635e4c7df0d105cf709">GetBit(int idx)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromBit</td><td>- The bit from which the printing starts in a <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">toBit</td><td>- The bit until which the printing in a <a class="el" href="class_c_bit_vector.html">CBitVector</a> is done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab345a6b215839a01e547ab3d54773646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::PrintContent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is a more abstract printing method which is used to print the <a class="el" href="class_c_bit_vector.html">CBitVector</a> even if the vector is a simple 1 bit based vector or 1-d array/vector or even a 2-d vector/array. This method internally calls methods <a class="el" href="class_c_bit_vector.html#adc0c87c5eddf7a18cf3145bd2ba64c36">Get(int i)</a> and <a class="el" href="class_c_bit_vector.html#a6c06ba63a5fbc2cda03a7fae02bd5709">Get2D(int i, int j)</a>. </p>

</div>
</div>
<a class="anchor" id="afec292cf93910f3ce9ca427f677958da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::PrintHex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method prints the <a class="el" href="class_c_bit_vector.html">CBitVector</a> in Hexadecimal format. </p>

</div>
</div>
<a class="anchor" id="a01eca0fb581fb6dc3a0fdaeb84069d7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::PrintHex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toByte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method prints the <a class="el" href="class_c_bit_vector.html">CBitVector</a> in Hexadecimal format for the provided byte range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromByte</td><td>- The byte from which the printing of <a class="el" href="class_c_bit_vector.html">CBitVector</a> begins. </td></tr>
    <tr><td class="paramname">toByte</td><td>- The byte until which the printing of <a class="el" href="class_c_bit_vector.html">CBitVector</a> is done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48146fc1124ad63d930a6ea3d8e76c11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to reset the values in the given <a class="el" href="class_c_bit_vector.html">CBitVector</a>. This method sets all bit values to zeros. This is a slight variant of the method <a class="el" href="class_c_bit_vector.html#a465c6c58b64215794bcbf927b79c6b0b">CreateZeros(uint64_t bits)</a>. The create method mentioned above allocates and sets value to zero. Whereas the provided method only sets the value to zero. </p>

</div>
</div>
<a class="anchor" id="a0d2f1256613f532b1d728c2c36223931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::ResetFromTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frombyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tobyte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to reset the values in the given <a class="el" href="class_c_bit_vector.html">CBitVector</a> for specific byte range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frombyte</td><td>- The source byte position from which the values needs to be reset. </td></tr>
    <tr><td class="paramname">tobyte</td><td>- The destination byte position until which the values needs to be reset to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4237185a0ebf54614bd6250b4e60a1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::ResizeinBytes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to resize the bytes allocated to <a class="el" href="class_c_bit_vector.html">CBitVector</a> with newly provided size. And also accommodate the data from previous allocation to new one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSizeBytes</td><td>- This variable provides the new size to which the cbitvector needs to be modified to user's needs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5573a0b254514ed8de9d7432e9d86033"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic method which performs the operation of setting values to a <a class="el" href="class_c_bit_vector.html">CBitVector</a> for a given bit position and length. This method internally calls <a class="el" href="class_c_bit_vector.html#a309ebf3ca25a520cba5c4fc3e35028f9">SetBits(BYTE* p, uint64_t pos, uint64_t len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- The positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> from which the data needs to obtained. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7394b44a53678cfc641730e655c7e496"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic method which provides more abstraction for setting elements in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. It is mainly used for getting values which are 1-dimensional in nature. This method internally calls <a class="el" href="">Set(int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>- Value which needs to be written to the given location. </td></tr>
    <tr><td class="paramname">i</td><td>- Index to which data needs to be written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15616ece0d9d626a6fabf1b0495ef580"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::Set2D </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic method which provides more abstraction for setting elements in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. It is mainly used for getting values which are 2-dimensional in nature. This method internally calls <a class="el" href="">Set(int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>- Value which needs to be written to the given location. </td></tr>
    <tr><td class="paramname">i</td><td>- Row index from which the data needs to be written. </td></tr>
    <tr><td class="paramname">j</td><td>- Column index from which the data needs to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad529794892a4a742851ccf77f37b72bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetAND </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to set and AND a <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a byte array and then AND it with another byte array for a given range. This method internally calls <a class="el" href="class_c_bit_vector.html#a1a05178228bc597a5a66c26cd3f8f0ef">Copy(BYTE* p, int pos, int len)</a> and <a class="el" href="class_c_bit_vector.html#a16049116df333c9498b2b26cde3530f4">ANDBytes(BYTE* p, int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Pointer to the byte location to be copied to the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">q</td><td>- Pointer to the byte location with which the <a class="el" href="class_c_bit_vector.html">CBitVector</a> is ANDed with. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset for copying and ANDing into current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be copied and ANDed to the current vector from provided byte location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c4775aef59942f5bef497a8e5ecd818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetBit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the bit in the provided index by using the maskbits and the provided bit. The maskbits brings the concept of endianness in the vector. In this method C_MASK_BIT is used to figure out the bits which are assumed to be organized in Little Endian form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Bit Index which needs to be written to in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>- The bit which being written in the provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9996cb024410ad0b0bc8fbc4496a82bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetBitNoMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the bit in the provided index without using the maskbits. The maskbits brings the concept of endianness in the vector. In this method mask bits are not used so the vector is treated in Big Endian form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Bit Index which needs to be written to in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>- The bit which being written in the provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a309ebf3ca25a520cba5c4fc3e35028f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetBits </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method for setting <a class="el" href="class_c_bit_vector.html">CBitVector</a> for a given bit range with offset and length in unsigned 64bit integer format. This method is called from <a class="el" href="class_c_bit_vector.html#a1cb6250074ff4317e67ecdfc99047260">SetBits(BYTE* p, int pos, int len)</a> and <a class="el" href="class_c_bit_vector.html#a5573a0b254514ed8de9d7432e9d86033">Set(T val, int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte array passed to be set to the current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>, where data will be set from the provided byte array. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cb6250074ff4317e67ecdfc99047260"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetBits </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The method for setting <a class="el" href="class_c_bit_vector.html">CBitVector</a> for a given bit range with offset and length in simple integer format. This method internally calls <a class="el" href="class_c_bit_vector.html#a309ebf3ca25a520cba5c4fc3e35028f9">SetBits(BYTE* p, uint64_t pos, uint64_t len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte array passed to be set to the current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>, where data will be set from the provided byte array. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18d1e30af12e0e4f4d432186c1b0b40d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetBitsPosOffset </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ppos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method for setting <a class="el" href="class_c_bit_vector.html">CBitVector</a> for a given bit range with offsets and length with another Byte Array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte array passed to be set with the current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">ppos</td><td>- Positional offset in the Byte Array. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>, where data will be set from the provided byte array. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cfcce1c2beadebd6762ea83f2b100a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetBitsToZero </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method sets the values in a given bit range to Zero in the current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitpos</td><td>- Bit Positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">bitlen</td><td>- Bit Length in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> until which the value needs to be set to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a0df36cd75420fbf3662b3b2a43ff98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetByte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets a byte in a given index of the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with the provided Byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Index where the byte needs to be set. </td></tr>
    <tr><td class="paramname">p</td><td>- Byte which needs to be copied to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57566943e8183748b39fa85805ef3fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetBytes </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method for setting <a class="el" href="class_c_bit_vector.html">CBitVector</a> for a given byte range with offset and length. This method internally calls the method <a class="el" href="class_c_bit_vector.html#a6a2f8e170922b9c991642a8d36043719">SetBytes(T* dst, T* src, T* lim)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte array passed to be set to the current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>, where data will be set from the provided byte array. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a2f8e170922b9c991642a8d36043719"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetBytes </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic method which performs the operation of setting bytes from source for the given limit. This method is called from <a class="el" href="class_c_bit_vector.html#a57566943e8183748b39fa85805ef3fff">SetBytes(BYTE* p, int pos, int len)</a>. </p>

</div>
</div>
<a class="anchor" id="a154810d495493eb274b0918deea159f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetElementLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elelen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the element length of the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. It can be used to modify the object size in a <a class="el" href="class_c_bit_vector.html">CBitVector</a> when around with the multi dimensional arrays/vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elelen</td><td>- New element length which can be used to set the object size in a <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac06967330a3ea126866475abb09d06b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetToOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets all bit position values in a <a class="el" href="class_c_bit_vector.html">CBitVector</a> to One. </p>

</div>
</div>
<a class="anchor" id="a833c9d66e3222c5e9a01d9a983961442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::SetXOR </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to set and XOR a <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a byte array and then XOR it with another byte array for a given range. This method internally calls <a class="el" href="class_c_bit_vector.html#a1a05178228bc597a5a66c26cd3f8f0ef">Copy(BYTE* p, int pos, int len)</a> and <a class="el" href="class_c_bit_vector.html#a263d8b59ba682177f0ce45fac658098c">XORBytes(BYTE* p, int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Pointer to the byte location to be copied to the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">q</td><td>- Pointer to the byte location with which the <a class="el" href="class_c_bit_vector.html">CBitVector</a> is XORed with. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset for copying and XORing into current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be copied and XORed to the current vector from provided byte location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec76212bf95a668f212f191dc70f5149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XOR </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic method which is used to XOR bit wise the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. This method internally calls <a class="el" href="class_c_bit_vector.html#a02d8f5d6f91e48534739b7f43943c9fb">XORBits(BYTE* p, int pos, int len)</a>. </p>

</div>
</div>
<a class="anchor" id="af7c591e1e5f5efdba62d28bb3c733515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XOR_no_mask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated </p>

</div>
</div>
<a class="anchor" id="a1c19baf537b532b74ee8d4f2fba516c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORBit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method XORs the bit in the provided index by using the maskbits and the provided bit. The maskbits brings the concept of endianness in the vector. In this method MASK_SET_BIT is used to extract and set the bits which are assumed to be organized in Little Endian form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Bit Index which needs to be XORed to in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>- The bit which being XORed in the provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72a741227827d658c1715deec220032b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORBitNoMask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method XORs the bit in the provided index without using the maskbits. The maskbits brings the concept of endianness in the vector. In this method mask bits are not used so the vector is treated in Big Endian form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Bit Index which needs to be XORed to in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>- The bit which being XORed in the provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02d8f5d6f91e48534739b7f43943c9fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORBits </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method for XORing <a class="el" href="class_c_bit_vector.html">CBitVector</a> for a given bit range with offset and length. This method is called from <a class="el" href="class_c_bit_vector.html#aec76212bf95a668f212f191dc70f5149">XOR(T val, int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte array passed to be XORed with the current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>, where data will be XORed from the provided byte array. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a057a35cc675262513498ac61cad198f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORBitsPosOffset </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ppos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method for XORing <a class="el" href="class_c_bit_vector.html">CBitVector</a> for a given bit range with offsets and length with another Byte Array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte array passed to be XORed with the current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">ppos</td><td>- Positional offset in the Byte Array. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset in the <a class="el" href="class_c_bit_vector.html">CBitVector</a>, where data will be XORed from the provided byte array. </td></tr>
    <tr><td class="paramname">len</td><td>- The range limit of obtaining the data from the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5896f8fca8729c743deac7e99c361ca7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORByte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Not Used Currently in Framework. This method performs XOR operation at the given index in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a provided Byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- Index of the byte which needs to be XORed inside the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>- Byte to be XORed with the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a263d8b59ba682177f0ce45fac658098c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORBytes </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method performs XOR operation from a given position in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a provided Byte Array with a length. This method is called from <a class="el" href="class_c_bit_vector.html#a498ce0adaeaf9fd9b56a362eada3bbba">XORBytes(BYTE* p, int len)</a>. This method internally calls <a class="el" href="class_c_bit_vector.html#af9265d158f116f48f4eec520a27212f1">XORBytes(T* dst, T* src, T* lim)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte Array to be XORed with the <a class="el" href="class_c_bit_vector.html">CBitVector</a> range. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset for XORing into current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be XORed to the current vector from provided byte location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a498ce0adaeaf9fd9b56a362eada3bbba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORBytes </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method performs XOR operation for a given length in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a provided Byte Array. This method internally calls <a class="el" href="class_c_bit_vector.html#a263d8b59ba682177f0ce45fac658098c">XORBytes(BYTE* p, int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte Array to be XORed with the <a class="el" href="class_c_bit_vector.html">CBitVector</a> range. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be XORed to the current vector from provided byte location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9265d158f116f48f4eec520a27212f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORBytes </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic method which is used to XOR byte wise the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. This method is called from <a class="el" href="class_c_bit_vector.html#a263d8b59ba682177f0ce45fac658098c">XORBytes(BYTE* p, int pos, int len)</a>. </p>

</div>
</div>
<a class="anchor" id="ac46c00c3986e7c22988a9e40ad1401b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORBytesReverse </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method performs XOR operation from a given position in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a provided Byte Array with a length. The XORing is performed in a slightly different way. The byte array is reversed before it is XORed with the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. This method is called from <a class="el" href="class_c_bit_vector.html#a498ce0adaeaf9fd9b56a362eada3bbba">XORBytes(BYTE* p, int len)</a>. This method internally calls <a class="el" href="class_c_bit_vector.html#af9265d158f116f48f4eec520a27212f1">XORBytes(T* dst, T* src, T* lim)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Byte Array to be XORed with the <a class="el" href="class_c_bit_vector.html">CBitVector</a> range. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset for XORing into current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be XORed to the current vector from provided byte location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6d21dc2673b728462c08eda0ff0d343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORRepeat </td>
          <td>(</td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated </p>

</div>
</div>
<a class="anchor" id="a9afd43a5ba95477f8a6d9746ec7f7a82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CBitVector::XORVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_bit_vector.html">CBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Not Used in the Framework. This method performs XOR operation from a given position in the <a class="el" href="class_c_bit_vector.html">CBitVector</a> with another <a class="el" href="class_c_bit_vector.html">CBitVector</a> with a length. This method internally calls <a class="el" href="class_c_bit_vector.html#a263d8b59ba682177f0ce45fac658098c">XORBytes(BYTE* p, int pos, int len)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- Provided Array to be XORed with the <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>- Positional offset for XORing into current <a class="el" href="class_c_bit_vector.html">CBitVector</a>. </td></tr>
    <tr><td class="paramname">len</td><td>- Length or amount of values to be XORed to the current vector from provided byte location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/abycore/util/<a class="el" href="cbitvector_8h_source.html">cbitvector.h</a></li>
<li>src/abycore/util/<a class="el" href="cbitvector_8cpp.html">cbitvector.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 26 2015 16:45:53 for ABY Framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
